import*as u from"@actions/core";import*as i from"@actions/github";import*as w from"@actions/artifact";import*as d from"@actions/exec";import*as y from"@actions/glob";import*as _ from"path";import x from"lcov-total";import g from"fs";import{config as c,inputs as a}from"./config";function f(){const e=i.context.payload.pull_request.head.sha;return{full:e,short:e.substr(0,7)}}function C(e){return`## ${e?"":":no_entry:"} Code coverage of commit [<code>${f().short}</code>](${i.context.payload.pull_request.number}/commits/${f().full})

`}function b(e){const{header:o,summary:n,details:t,isMinimumCoverageReached:r,errorMessage:s}=e;return`${o}<pre>${n}

Changed files coverage rate: ${t}</pre>

${r?"":`:no_entry: ${s}`}`}function $(){return["pull_request","pull_request_target"].includes(i.context.eventName)}async function F(e){return(await e.rest.issues.listComments({repo:i.context.repo.repo,owner:i.context.repo.owner,issue_number:i.context.payload.pull_request.number})).data.find(n=>n.body.includes("Code coverage"))}async function R(e){const{updateComment:o,body:n,octokit:t}=e,r=await F(t),s=o&&r,l=s?t.rest.issues.updateComment:t.rest.issues.createComment,p={repo:i.context.repo.repo,owner:i.context.repo.owner,body:n,...s?{comment_id:r.id}:{issue_number:i.context.payload.pull_request.number}};l(p)}function P(e){return Math.round(e*10)/10}async function h(e){return(await(await y.create(e)).glob()).filter(t=>{try{return g.statSync(t).isFile()}catch(r){return console.log(r.message),!1}})}function H(){try{const e=`${process.env.GITHUB_WORKSPACE}/lcov-tmp-dir`;return g.mkdirSync(e),e}catch(e){u.error(`${c.action_msg_prefix} creating a temp dir failed with: ${e.message}`),process.exit(1)}}async function k(){const e=H();try{const o=await h(a.coverageFilesPattern);o.length||(u.error(`${c.action_msg_prefix} no coverage lcov files found with pattern ${a.coverageFilesPattern}`),process.exit(1));const n=await S(o,e),t=P(x(n)),r=`Code coverage: **${t}** %. Expected at least **${a.minimumCoverage}** %.`,s=t>=a.minimumCoverage;if(a.gitHubToken&&$()){const l=i.getOctokit(a.gitHubToken),p=b({header:C(s),summary:await T(n),details:await E(n,l),isMinimumCoverageReached:s,errorMessage:r});R({octokit:l,updateComment:a.updateComment,body:p})}else u.warning(`${c.action_msg_prefix} no github-token provided or not running in a PR workflow. Skipping creating a PR comment.`);a.artifactName&&q(o,a.artifactName,e),u.setOutput("total-coverage",t),s||u.setFailed(r.replace(/\*/g,""))}catch(o){u.setFailed(`${c.action_msg_prefix} ${o.message}`)}}async function q(e,o,n){const t=_.resolve(n,"html").trim(),r=[...e,...c.common_lcov_args,"--output-directory",t];await d.exec("genhtml",r,{cwd:a.workingDirectory});const s=await h(`${t}/**`);w.create().uploadArtifact(o,s,t,{continueOnError:!1})}async function S(e,o){const n=`${o}/merged-lcov.info`,t=[];for(const r of e)t.push("--add-tracefile"),t.push(r);return t.push("--output-file"),t.push(n),await d.exec("lcov",[...t,...c.common_lcov_args]),n}async function T(e){let o="";const n={listeners:{stdout:r=>{o+=r.toString()},stderr:r=>{o+=r.toString()}}};await d.exec("lcov",["--summary",e,...c.common_lcov_args],n);const t=o.trim().split(c.newline);return t.shift(),t.join(`
`)}async function M(e){const o=e.rest.pulls.listFiles.endpoint.merge({owner:i.context.repo.owner,repo:i.context.repo.repo,pull_number:i.context.payload.pull_request.number});return(await e.paginate(o)).map(t=>t.filename)}function O(e,o){return o.some(n=>e.startsWith(n))}async function E(e,o){let n="";const t={listeners:{stdout:m=>{n+=m.toString()},stderr:m=>{n+=m.toString()}}},r=a.listFullPaths?["--list-full-path"]:[];await d.exec("lcov",["--list",e,...r,...c.common_lcov_args],t);let s=n.trim().split(c.newline);s.shift(),s.pop(),s.pop();const l=await M(o);return s=s.filter((m,v)=>v<=2?!0:O(m,l)),s.length===3?"n/a":`
  ${s.join(`
  `)}`}k();
//# sourceMappingURL=index.js.map
