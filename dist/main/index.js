import*as c from"@actions/core";import*as g from"@actions/github";import*as v from"@actions/artifact";import*as u from"@actions/exec";import*as w from"@actions/glob";import*as _ from"path";import y from"lcov-total";import $ from"fs";import{config as s,inputs as a}from"./config";import{getChangedFilenames as b,commentOnPR as C,sha as f}from"./github";function x(e){return`## ${e?"":":no_entry:"} Code coverage of commit [<code>${f().short}</code>](${g.context.payload.pull_request.number}/commits/${f().full})

`}function F(e){const{header:r,summary:t,details:o,isMinimumCoverageReached:i,errorMessage:n}=e;return`${r}<pre>${t}

Changed files coverage rate: ${o}</pre>

${i?"":`:no_entry: ${n}`}`}function H(){return["pull_request","pull_request_target"].includes(g.context.eventName)}function P(e){return Math.round(e*10)/10}async function p(e){return await(await w.create(e,{followSymbolicLinks:!1,matchDirectories:!1})).glob()}function R(){try{const e=`${process.env.GITHUB_WORKSPACE}/lcov-tmp-dir`;return $.mkdirSync(e),e}catch(e){c.error(`${s.action_msg_prefix} creating a temp dir failed with: ${e.message}`),process.exit(1)}}async function k(){const e=await p(a.coverageFilesPattern);e.length||(c.error(`${s.action_msg_prefix} no coverage lcov files found with pattern ${a.coverageFilesPattern}`),process.exit(1));const r=R();try{const t=await T(e,r),o=P(y(t)),i=`Code coverage: **${o}** %. Expected at least **${a.minimumCoverage}** %.`,n=o>=a.minimumCoverage;if(a.gitHubToken&&H()){const m=g.getOctokit(a.gitHubToken),d=F({header:x(n),summary:await M(t),details:await D(t,m),isMinimumCoverageReached:n,errorMessage:i});C({octokit:m,updateComment:a.updateComment,body:d})}else c.warning(`${s.action_msg_prefix} no github-token provided or not running in a PR workflow. Skipping creating a PR comment.`);a.artifactName&&S(e,a.artifactName,r),c.setOutput("total-coverage",o),n||c.setFailed(i.replace(/\*/g,""))}catch(t){c.setFailed(`${s.action_msg_prefix} ${t.message}`)}}async function S(e,r,t){const o=_.resolve(t,"html").trim(),i=[...e,...s.common_lcov_args,"--output-directory",o];await u.exec("genhtml",i,{cwd:a.workingDirectory});const n=await p(`${o}/**`);v.create().uploadArtifact(r,n,o,{continueOnError:!1})}async function T(e,r){const t=`${r}/merged-lcov.info`,o=[];for(const i of e)o.push("--add-tracefile"),o.push(i);return o.push("--output-file"),o.push(t),await u.exec("lcov",[...o,...s.common_lcov_args]),t}async function M(e){let r="";const t={listeners:{stdout:i=>{r+=i.toString()},stderr:i=>{r+=i.toString()}}};await u.exec("lcov",["--summary",e,...s.common_lcov_args],t);const o=r.trim().split(s.newline);return o.shift(),o.join(`
`)}function O(e,r){return r.some(t=>e.startsWith(t))}async function D(e,r){let t="";const o={listeners:{stdout:l=>{t+=l.toString()},stderr:l=>{t+=l.toString()}}},i=a.listFullPaths?["--list-full-path"]:[];await u.exec("lcov",["--list",e,...i,...s.common_lcov_args],o);let n=t.trim().split(s.newline);n.shift(),n.pop(),n.pop();const m=await b(r);return n=n.filter((l,h)=>h<=2?!0:O(l,m)),n.length===3?"n/a":`
  ${n.join(`
  `)}`}k();
//# sourceMappingURL=index.js.map
