import*as u from"@actions/core";import*as i from"@actions/github";import*as v from"@actions/artifact";import*as d from"@actions/exec";import*as w from"@actions/glob";import*as y from"path";import _ from"lcov-total";import b from"fs";import{config as c,inputs as a}from"./config";function g(){const e=i.context.payload.pull_request.head.sha;return{full:e,short:e.substr(0,7)}}function x(e){return`## ${e?"":":no_entry:"} Code coverage of commit [<code>${g().short}</code>](${i.context.payload.pull_request.number}/commits/${g().full})

`}function C(e){const{header:n,summary:o,details:t,isMinimumCoverageReached:s,errorMessage:r}=e;return`${n}<pre>${o}

Changed files coverage rate: ${t}</pre>

${s?"":`:no_entry: ${r}`}`}function $(){return["pull_request","pull_request_target"].includes(i.context.eventName)}async function F(e){return(await e.rest.issues.listComments({repo:i.context.repo.repo,owner:i.context.repo.owner,issue_number:i.context.payload.pull_request.number})).data.find(o=>o.body.includes("Code coverage"))}async function R(e){const{updateComment:n,body:o,octokit:t}=e,s=await F(t),r=n&&s,l=r?t.rest.issues.updateComment:t.rest.issues.createComment,p={repo:i.context.repo.repo,owner:i.context.repo.owner,body:o,...r?{comment_id:s.id}:{issue_number:i.context.payload.pull_request.number}};l(p)}function P(e){return Math.round(e*10)/10}async function f(e){return await(await w.create(e,{followSymbolicLinks:!1,matchDirectories:!1})).glob()}function H(){try{const e=`${process.env.GITHUB_WORKSPACE}/lcov-tmp-dir`;return b.mkdirSync(e),e}catch(e){u.error(`${c.action_msg_prefix} creating a temp dir failed with: ${e.message}`),process.exit(1)}}async function k(){const e=H(),n=await f(a.coverageFilesPattern);n.length||(u.error(`${c.action_msg_prefix} no coverage lcov files found with pattern ${a.coverageFilesPattern}`),process.exit(1));try{const o=await S(n,e),t=P(_(o)),s=`Code coverage: **${t}** %. Expected at least **${a.minimumCoverage}** %.`,r=t>=a.minimumCoverage;if(a.gitHubToken&&$()){const l=i.getOctokit(a.gitHubToken),p=C({header:x(r),summary:await T(o),details:await E(o,l),isMinimumCoverageReached:r,errorMessage:s});R({octokit:l,updateComment:a.updateComment,body:p})}else u.warning(`${c.action_msg_prefix} no github-token provided or not running in a PR workflow. Skipping creating a PR comment.`);a.artifactName&&q(n,a.artifactName,e),u.setOutput("total-coverage",t),r||u.setFailed(s.replace(/\*/g,""))}catch(o){u.setFailed(`${c.action_msg_prefix} ${o.message}`)}}async function q(e,n,o){const t=y.resolve(o,"html").trim(),s=[...e,...c.common_lcov_args,"--output-directory",t];await d.exec("genhtml",s,{cwd:a.workingDirectory});const r=await f(`${t}/**`);v.create().uploadArtifact(n,r,t,{continueOnError:!1})}async function S(e,n){const o=`${n}/merged-lcov.info`,t=[];for(const s of e)t.push("--add-tracefile"),t.push(s);return t.push("--output-file"),t.push(o),await d.exec("lcov",[...t,...c.common_lcov_args]),o}async function T(e){let n="";const o={listeners:{stdout:s=>{n+=s.toString()},stderr:s=>{n+=s.toString()}}};await d.exec("lcov",["--summary",e,...c.common_lcov_args],o);const t=n.trim().split(c.newline);return t.shift(),t.join(`
`)}async function M(e){const n=e.rest.pulls.listFiles.endpoint.merge({owner:i.context.repo.owner,repo:i.context.repo.repo,pull_number:i.context.payload.pull_request.number});return(await e.paginate(n)).map(t=>t.filename)}function O(e,n){return n.some(o=>e.startsWith(o))}async function E(e,n){let o="";const t={listeners:{stdout:m=>{o+=m.toString()},stderr:m=>{o+=m.toString()}}},s=a.listFullPaths?["--list-full-path"]:[];await d.exec("lcov",["--list",e,...s,...c.common_lcov_args],t);let r=o.trim().split(c.newline);r.shift(),r.pop(),r.pop();const l=await M(n);return r=r.filter((m,h)=>h<=2?!0:O(m,l)),r.length===3?"n/a":`
  ${r.join(`
  `)}`}k();
//# sourceMappingURL=index.js.map
